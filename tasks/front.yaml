---
- name: Create a directory if it does not exist
  file:
    path: /etc/kubernetes/pki
    state: directory
    mode: '0755'

- name: Create auth data file with an admin user
  copy:
    content: '{{ kube_admin_token }},{{ kube_admin_username }},100,"users,system:masters"'
    dest: /etc/kubernetes/pki/auth
    mode: 600

- name: Kubeadm init
  command: kubeadm init --pod-network-cidr={{ kube_pod_network_cidr }} --token={{ kube_token }} --token-ttl {{ kube_token_ttl }} --apiserver-advertise-address={{ kube_api_server }} creates=/etc/kubernetes/admin.conf

- name: Wait Kube to start
  wait_for:
    host: "{{ kube_api_server }}"
    port: 6443

- name: Install flannel
  block:
  - template:
      src: templates/flannel.yaml
      dest: /etc/kube-flannel.yml
  - command: kubectl apply -f /etc/kube-flannel.yml creates=/etc/cni/net.d/10-flannel.conflist
    environment:
      KUBECONFIG: /etc/kubernetes/admin.conf
  when: network_manager == "flannel"

- name: Install calico
  block:
  - get_url:
      url: https://projectcalico.docs.tigera.io/archive/{{ calico_version }}/manifests/calico.yaml
      dest: /etc/kube-calico.yml
  - command: kubectl apply -f /etc/kube-calico.yml
    environment:
      KUBECONFIG: /etc/kubernetes/admin.conf
  when: network_manager == "calico"

- include: helm.yaml
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  when: kube_install_helm

#- name: Add Kube API server options
#  lineinfile:
#    path: /etc/kubernetes/manifests/kube-apiserver.yaml
#    line: '    - {{ item.option }}={{ item.value }}'
#    regexp: '^    - {{ item.option }}='
#    insertafter: '    - kube-apiserver'
#  notify: restart kubeapi
#  with_items: "{{ kube_apiserver_options }}"

- name: Wait Kube to start
  wait_for:
    host: "{{ kube_api_server }}"
    port: 6443

- name: Set iptables for ingress floatingIPs
  block:
  - name: Delete all rules in all chains
    iptables: 
      flush: yes
  - name: 'iptables -A FORWARD -p tcp -d {{ nginx_ingress.master_private_ip }} --dport 443,80 -j ACCEPT'
    iptables:
      chain: FORWARD
      protocol: tcp
      destination: "{{ nginx_ingress.master_private_ip }}"
      destination_port: "{{ item }}"
      jump: ACCEPT
      comment: "managed by kubernetes ansible role"
    loop:
      - 443
      - 80        
  - name: 'iptables -t nat -A PREROUTING -p tcp -d {{ nginx_ingress.master_public_ip }} --dport 443,80 -j DNAT --to-destination {{ nginx_ingress.master_private_ip }}:443,80'
    iptables:
      table: nat
      chain: PREROUTING
      protocol: tcp
      destination: "{{ nginx_ingress.master_public_ip }}"
      destination_port: "{{ item }}"
      jump: DNAT
      to_destination: "{{ nginx_ingress.master_private_ip }}:{{ item }}"
      comment: "managed by kubernetes ansible role"
    loop:
      - 443
      - 80              
  - name: 'iptables -t nat -A POSTROUTING ! -s 127.0.0.1 -j MASQUERADE'
    iptables:
      table: nat     
      chain: POSTROUTING
      source: '! 127.0.0.1'
      jump: MASQUERADE
      comment: "managed by kubernetes ansible role"
  - name: save iptable configuration
    command: iptables-save

- name: Wait Kube to start
  wait_for:
    host: "{{ kube_api_server }}"
    port: 6443

- name: Collect NotReady nodes
  ansible.builtin.shell: "kubectl get nodes | grep NotReady | grep -v vnode-0 | awk '{print $1}'"
  register: notready_nodes
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  failed_when: false
  changed_when: false

- name: NotReady nodes
  ansible.builtin.debug:
    msg: "NotReady nodes: {{ notready_nodes.stdout }}"

- name: Cordon nodes
  ansible.builtin.shell: "kubectl cordon {{ item }} "
  loop:
    "{{ notready_nodes.stdout.split('\n') }}"
  register: output_cordon
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  when: notready_nodes.stdout | length > 0

- name: Output cordon nodes
  ansible.builtin.debug:
    msg: "Cordoned nodes: {{ output_cordon }}"
  when: notready_nodes.stdout | length > 0

#- name: Drain nodes
#  ansible.builtin.shell: "kubectl drain {{ item }} --delete-emptydir-data --ignore-daemonsets --force"
#  loop:
#    "{{ notready_nodes.stdout.split('\n') }}"
#  environment:
#    KUBECONFIG: /etc/kubernetes/admin.conf
#  register: output_drain
#  when: notready_nodes.stdout | length > 0

#- name: Output drain nodes
#  ansible.builtin.debug:
#    msg: "Drain nodes: {{ output_drain }}"
#  when: notready_nodes.stdout | length > 0

- name: Delete NotReady nodes
  ansible.builtin.shell: "kubectl delete node {{ item }} "
  loop:
    "{{ notready_nodes.stdout.split('\n') }}"
  register: output_delete
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  when: notready_nodes.stdout | length > 0

- name: Output node deletion
  ansible.builtin.debug:
    msg: "Deleted nodes: {{ output_delete }}"
  when: notready_nodes.stdout | length > 0

- name: Check if ingress-nginx is already installed
  ansible.builtin.shell: "helm list -a -n ingress-nginx"
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  register: ingress_nginx_present

- name: Install nginx ingress
  when: nginx_ingress.enabled and ('ingress-nginx' not in ingress_nginx_present.stdout)
  block:  
  - template:
      src: templates/nginx-values.yaml
      dest: /etc/nginx-ingress-values.yml
  - command: "{{ item }}"
    environment:
      KUBECONFIG: /etc/kubernetes/admin.conf
    with_items:
      - helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
      - helm repo update
      - "helm install ingress-nginx ingress-nginx/ingress-nginx  --atomic --set controller.allowSnippetAnnotations=false \
        -n ingress-nginx --create-namespace --version {{ nginx_ingress_helm_version }} --values /etc/nginx-ingress-values.yml"
  
- name: Check if cert-manager is already installed
  ansible.builtin.shell: "helm list -a -n cert-manager"
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  register: cert_manager_present

- name: Install cert manager
  when: nginx_ingress.enabled and ('cert-manager' not in cert_manager_present.stdout)
  command: "{{ item }}"
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  with_items:
    - helm repo add jetstack https://charts.jetstack.io
    - helm repo update
    - "helm install cert-manager jetstack/cert-manager --atomic -n cert-manager --create-namespace --version {{ cert_manager_helm_version }} --set installCRDs=true"
 
- name: wait Cert-Manager to start
  command: kubectl get deployment -n cert-manager -l 'app=webhook' -o 'jsonpath={.items[0].status.readyReplicas}'
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  register: cert_manager_webhook_deployment_status
  until: (cert_manager_webhook_deployment_status.stdout | default(0) | int) >= 1
  retries: 30
  delay: 15
  when: nginx_ingress.enabled

- name: define cluster issuer
  block:
  - template:
      src: templates/cluster-certs.yaml
      dest: /etc/cluster-certs.yml 
  - command: kubectl apply -f /etc/cluster-certs.yml
    environment:
      KUBECONFIG: /etc/kubernetes/admin.conf

- name: Check if dashboard is already installed
  ansible.builtin.shell: "helm list -a -n kube-system"
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  register: dashboard_present

- name: install dashboard
  when: nginx_ingress.enabled and ('dashboard' not in dashboard_present.stdout)
  block:
  - copy:
      src: files/metric-server.yaml
      dest: /etc/metric-server.yml
  - template:
      src: templates/dashboard-values.yaml
      dest: /etc/dashboard-values.yml
  - command: "{{ item }}"
    environment:
      KUBECONFIG: /etc/kubernetes/admin.conf
    with_items:
      - helm repo add kubernetes-dashboard https://kubernetes.github.io/dashboard/
      - helm repo update
      - kubectl apply -f /etc/metric-server.yml
      - "helm install dashboard kubernetes-dashboard/kubernetes-dashboard --atomic -n kube-system --version {{ dashboard_helm_version }} --values /etc/dashboard-values.yml"
  
- name: Check if prometheus is already installed
  ansible.builtin.shell: "helm list -a -n prometheus"
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  register: prometheus_present

- name: Install prometheus
  when: (nginx_ingress.enabled) and ('prometheus' not in prometheus_present.stdout)
  block:
  - template:
      src: templates/prometheus-values.yaml
      dest: /etc/prometheus-values.yml
  - command: "{{ item }}"
    environment:
      KUBECONFIG: /etc/kubernetes/admin.conf
    with_items:
      - helm repo add prometheus https://prometheus-community.github.io/helm-charts
      - helm repo update
      - "helm install prometheus prometheus/prometheus --atomic -n prometheus --create-namespace --version {{ prometheus_helm_version }} --values /etc/prometheus-values.yml"

- name: Check if kube-eagle is already installed
  ansible.builtin.shell: "helm list -a -n kube-eagle"
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  register: kube_eagle_present

- name: Install kube-eagle
  when: nginx_ingress.enabled and ('kube-eagle' not in kube_eagle_present.stdout)
  ansible.builtin.command: "{{ item }}"
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  with_items:
    - helm repo add kube-eagle https://raw.githubusercontent.com/cloudworkz/kube-eagle-helm-chart/master
    - helm repo update
    - "helm install kube-eagle kube-eagle/kube-eagle --atomic -n kube-eagle --create-namespace --version {{ kube_eagle_helm_version }}"


- name: Check if grafana is already installed
  ansible.builtin.shell: "helm list -a -n grafana"
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf
  register: grafana_present

- name: Install grafana
  when: nginx_ingress.enabled and ('grafana' not in grafana_present.stdout)
  block:
    - name: Copy templates/grafana-secret.yaml
      ansible.builtin.template:
        src: templates/grafana-secret.yaml
        dest: /etc/grafana-secret.yml
        mode: 0644
    - name: Copy templates/grafana-values.yaml
      ansible.builtin.template:
        src: templates/grafana-values.yaml
        dest: /etc/grafana-values.yml
        mode: 0644
    - name: Create grafana namespace
      ansible.builtin.command: kubectl create ns grafana
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
    - name: Create grafana secret
      ansible.builtin.command: kubectl apply -n grafana -f /etc/grafana-secret.yml
      register: kubectl_grafana_secret_apply
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      changed_when:
        - kubectl_grafana_secret_apply.rc == 0
    - name: Install grafana
      ansible.builtin.command: "{{ item }}"
      environment:
        KUBECONFIG: /etc/kubernetes/admin.conf
      with_items:
        - helm repo add grafana https://grafana.github.io/helm-charts
        - helm repo update
        - "helm install grafana grafana/grafana --atomic -n grafana --version {{ grafana_helm_version }} --values /etc/grafana-values.yml"


- name: Expose apiserver through ingress
  block:
  - template:
      src: templates/api-server-ingress.yaml
      dest: /etc/api-server-ingress.yaml
  - command: kubectl apply -f /etc/api-server-ingress.yaml
    environment:
      KUBECONFIG: /etc/kubernetes/admin.conf

- name: Create service account for remote access
  block:
  - copy:
      src: files/kubeconfig
      dest: /etc/kubeconfig
  - copy:
      src: files/admin-cred.yaml
      dest: /etc/admin-cred.yml
  - shell: |
      kubectl apply -f /etc/admin-cred.yml
      kubectl create --dry-run=client clusterrolebinding add-on-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:admin -o yaml | kubectl apply -f -
      export TOKEN=$(kubectl -n kube-system get secret admin-token -o jsonpath='{.data.token}' | base64 -d)
      kubectl config --kubeconfig=/etc/kubeconfig set-credentials admin --token=$TOKEN
      kubectl config --kubeconfig=/etc/kubeconfig set-cluster public --server=https://api-kubernetes.{{ dns_name }} --insecure-skip-tls-verify
      kubectl config --kubeconfig=/etc/kubeconfig set-context public --cluster=public --namespace=default --user=admin
      kubectl config --kubeconfig=/etc/kubeconfig use-context public
    environment:
      KUBECONFIG: /etc/kubernetes/admin.conf

- name: Register kubeconfig
  shell: kubectl config --kubeconfig=/etc/kubeconfig view --raw
  register: kubeconfig
  environment:
    KUBECONFIG: /etc/kubernetes/admin.conf

- name: KUBECONFIG file
  debug:
    var: kubeconfig.stdout.split('\n')
